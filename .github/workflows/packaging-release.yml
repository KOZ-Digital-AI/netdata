---
# ============================================================================
# FORK MODIFICATION: Automated Package Release Workflow
# ============================================================================
# This workflow automatically uploads build artifacts from the packaging
# workflow to a continuously updated "Latest Packages" GitHub release.
#
# Purpose:
#   - Runs after packaging workflow completion on master branch (success or failure)
#   - Can also be manually triggered to create releases from any workflow run
#   - Downloads successful package artifact archives (one per distro-version-arch)
#   - Creates zip archives for each build job's packages
#   - Uploads archives to a single "latest" release (not individual packages)
#   - Gracefully handles partial build failures
#   - Does not fail if some package builds failed
#
# Release Structure:
#   - Each asset is a .zip archive containing packages for one distro-version-arch
#   - Example: ubuntu-24.04-amd64-packages.zip, debian-12-arm64-packages.zip
#   - Users download only the archive they need for their system
#   - SHA256SUMS file included for verification
#
# Merge Considerations:
#   - This is a fork-specific workflow file
#   - Should not conflict with upstream as it's not present in upstream
#   - Safe to keep during merges from netdata/netdata
# ============================================================================

name: Package Release

# Triggers:
#   1. Automatically after "Packages" workflow completes (success, failure, or cancelled)
#   2. Manually via workflow_dispatch with optional workflow run ID
on:
  workflow_run:
    workflows: ["Packages"]
    types:
      - completed
    branches:
      - master

  # Allow manual triggering to create releases from specific workflow runs
  workflow_dispatch:
    inputs:
      workflow_run_id:
        description: 'Workflow run ID from Packages workflow (leave empty to use latest completed run)'
        required: false
        type: string

jobs:
  update-release:
    name: Update Latest Release
    runs-on: ubuntu-latest

    # Run conditions:
    #   - For workflow_run: only on master branch
    #   - For workflow_dispatch: always run
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.head_branch == 'master'

    steps:
      # Checkout repository to get access to any scripts if needed
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Determine which workflow run ID to use for artifact download
      # Supports both automatic (workflow_run) and manual (workflow_dispatch) triggers
      - name: Determine Workflow Run ID
        id: get-run-id
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger
            if [ -n "${{ inputs.workflow_run_id }}" ]; then
              # User provided specific run ID
              echo "run_id=${{ inputs.workflow_run_id }}" >> $GITHUB_OUTPUT
              echo "üìã Using specified workflow run ID: ${{ inputs.workflow_run_id }}"
            else
              # Find the latest completed Packages workflow run
              echo "üîç Finding latest Packages workflow run..."
              RUN_ID=$(gh run list --workflow=packaging.yml --branch=master --limit=1 --json databaseId --jq '.[0].databaseId')
              echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
              echo "üìã Using latest workflow run ID: $RUN_ID"
            fi
          else
            # Automatic trigger from workflow_run
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "üìã Using workflow_run ID: ${{ github.event.workflow_run.id }}"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Get workflow run details for release notes
      # Fetches information about the workflow run to include in release body
      - name: Get Workflow Run Details
        id: workflow-details
        run: |
          RUN_ID="${{ steps.get-run-id.outputs.run_id }}"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Fetch workflow run details via API for manual triggers
            echo "üîç Fetching workflow run details for run ID: $RUN_ID"
            gh api "/repos/${{ github.repository }}/actions/runs/$RUN_ID" \
              --jq '{
                head_branch: .head_branch,
                head_sha: .head_sha,
                updated_at: .updated_at,
                html_url: .html_url,
                conclusion: .conclusion
              }' > run_details.json

            HEAD_BRANCH=$(jq -r '.head_branch' run_details.json)
            HEAD_SHA=$(jq -r '.head_sha' run_details.json)
            UPDATED_AT=$(jq -r '.updated_at' run_details.json)
            HTML_URL=$(jq -r '.html_url' run_details.json)
            CONCLUSION=$(jq -r '.conclusion' run_details.json)

            echo "head_branch=$HEAD_BRANCH" >> $GITHUB_OUTPUT
            echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT
            echo "updated_at=$UPDATED_AT" >> $GITHUB_OUTPUT
            echo "html_url=$HTML_URL" >> $GITHUB_OUTPUT
            echo "conclusion=$CONCLUSION" >> $GITHUB_OUTPUT
          else
            # Use workflow_run event data for automatic triggers
            echo "head_branch=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
            echo "head_sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
            echo "updated_at=${{ github.event.workflow_run.updated_at }}" >> $GITHUB_OUTPUT
            echo "html_url=${{ github.event.workflow_run.html_url }}" >> $GITHUB_OUTPUT
            echo "conclusion=${{ github.event.workflow_run.conclusion }}" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Download all available artifacts from the completed packaging workflow
      # Using GitHub CLI which is pre-installed in ubuntu-latest runners
      # GitHub Actions automatically packages artifacts as zip files
      # We keep them as zips instead of extracting individual packages
      - name: Download Available Artifacts from Packaging Workflow
        id: download-artifacts
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Downloading artifact archives from workflow run: ${{ steps.get-run-id.outputs.run_id }}"
          mkdir -p artifact-archives

          # Download artifacts as zip files
          # gh run download preserves the GitHub Actions zip format
          if gh run download ${{ steps.get-run-id.outputs.run_id }} --dir artifact-archives/ 2>&1 | tee download.log; then
            echo "‚úÖ Artifact download completed"
            echo "success=true" >> $GITHUB_OUTPUT
          else
            # Check if any artifacts were downloaded despite errors
            if [ -n "$(find artifact-archives/ -type d -mindepth 1 2>/dev/null)" ]; then
              echo "‚ö†Ô∏è Partial download - some artifacts may be missing"
              echo "success=partial" >> $GITHUB_OUTPUT
            else
              echo "‚ùå No artifacts downloaded"
              echo "success=false" >> $GITHUB_OUTPUT
            fi
          fi

          echo "Downloaded artifact directories:"
          ls -la artifact-archives/ || echo "No artifact-archives directory"

      # Create zip archives from downloaded artifacts
      # The packaging workflow creates artifacts named like:
      #   - debian-12-amd64-packages
      #   - ubuntu-24.04-arm64-packages
      #   - rockylinux-9-x86_64-packages
      # gh run download extracts them to directories, we need to re-zip them
      - name: Create Zip Archives for Release
        id: organize
        if: steps.download-artifacts.outputs.success != 'false'
        continue-on-error: true
        run: |
          echo "Creating zip archives from artifacts..."
          mkdir -p release-assets

          # Count artifacts
          ARTIFACT_COUNT=0
          DEB_ARCHIVE_COUNT=0
          RPM_ARCHIVE_COUNT=0

          # Process each artifact directory
          cd artifact-archives
          for artifact_dir in */; do
            if [ -d "$artifact_dir" ]; then
              ARTIFACT_NAME="${artifact_dir%/}"
              echo "Processing artifact: $ARTIFACT_NAME"

              # Check if directory contains any package files
              if [ -n "$(find "$artifact_dir" -type f \( -name "*.deb" -o -name "*.rpm" -o -name "*.ddeb" \) 2>/dev/null)" ]; then
                # Create zip archive from the artifact directory
                zip -r "../release-assets/${ARTIFACT_NAME}.zip" "$ARTIFACT_NAME" >/dev/null 2>&1

                if [ -f "../release-assets/${ARTIFACT_NAME}.zip" ]; then
                  ARTIFACT_COUNT=$((ARTIFACT_COUNT + 1))

                  # Count by type (check if it contains .deb or .rpm)
                  if find "$artifact_dir" -name "*.deb" 2>/dev/null | grep -q .; then
                    DEB_ARCHIVE_COUNT=$((DEB_ARCHIVE_COUNT + 1))
                  elif find "$artifact_dir" -name "*.rpm" 2>/dev/null | grep -q .; then
                    RPM_ARCHIVE_COUNT=$((RPM_ARCHIVE_COUNT + 1))
                  fi

                  echo "‚úÖ Created: ${ARTIFACT_NAME}.zip"
                else
                  echo "‚ö†Ô∏è  Failed to create zip for: $ARTIFACT_NAME"
                fi
              else
                echo "‚ö†Ô∏è  Skipping $ARTIFACT_NAME - no package files found"
              fi
            fi
          done
          cd ..

          # Check if we have any archives
          if [ "$ARTIFACT_COUNT" -eq 0 ]; then
            echo "‚ùå No package archives created"
            echo "has_archives=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_archives=true" >> $GITHUB_OUTPUT

          # Display what we're going to upload
          echo ""
          echo "üì¶ Package archives ready for release:"
          ls -lh release-assets/

          # Save counts
          echo "archive_count=$ARTIFACT_COUNT" >> $GITHUB_OUTPUT
          echo "deb_archive_count=$DEB_ARCHIVE_COUNT" >> $GITHUB_OUTPUT
          echo "rpm_archive_count=$RPM_ARCHIVE_COUNT" >> $GITHUB_OUTPUT

          echo ""
          echo "Total: $ARTIFACT_COUNT archives ($DEB_ARCHIVE_COUNT deb-based, $RPM_ARCHIVE_COUNT rpm-based)"

      # Generate SHA256 checksums for archive verification
      - name: Generate Checksums
        if: steps.organize.outputs.has_archives == 'true'
        continue-on-error: true
        working-directory: release-assets
        run: |
          echo "Generating SHA256 checksums for archives..."
          sha256sum *.zip > SHA256SUMS 2>/dev/null || true
          echo ""
          echo "Checksums generated:"
          cat SHA256SUMS

      # Determine build status for release notes
      - name: Determine Build Status
        id: status
        if: steps.organize.outputs.has_archives == 'true'
        run: |
          if [ "${{ steps.workflow-details.outputs.conclusion }}" = "success" ]; then
            echo "status_emoji=‚úÖ" >> $GITHUB_OUTPUT
            echo "status_text=All package builds succeeded" >> $GITHUB_OUTPUT
          elif [ "${{ steps.download-artifacts.outputs.success }}" = "partial" ]; then
            echo "status_emoji=‚ö†Ô∏è" >> $GITHUB_OUTPUT
            echo "status_text=Partial build - some package builds may have failed" >> $GITHUB_OUTPUT
          else
            echo "status_emoji=‚ö†Ô∏è" >> $GITHUB_OUTPUT
            echo "status_text=Some package builds failed - only successful builds included" >> $GITHUB_OUTPUT
          fi

      # Create or update the "latest" release
      # This removes old artifacts and uploads new ones
      - name: Create/Update Latest Release
        if: steps.organize.outputs.has_archives == 'true'
        uses: ncipollo/release-action@v1
        with:
          # Allow updating existing release
          allowUpdates: true

          # Remove old artifacts before uploading new ones
          # This keeps the release clean and prevents accumulation
          removeArtifacts: true

          # Upload all archive files and checksums
          artifacts: 'release-assets/*'

          # Release body with build information
          body: |
            ## Latest Automated Package Builds

            This release is automatically updated with the latest package builds from the master branch.

            ### Build Status
            ${{ steps.status.outputs.status_emoji }} **${{ steps.status.outputs.status_text }}**

            ### Build Information
            - **Branch**: ${{ steps.workflow-details.outputs.head_branch }}
            - **Commit**: ${{ steps.workflow-details.outputs.head_sha }}
            - **Build Date**: ${{ steps.workflow-details.outputs.updated_at }}
            - **Workflow Run**: [${{ steps.get-run-id.outputs.run_id }}](${{ steps.workflow-details.outputs.html_url }})
            - **Package Archives**: ${{ steps.organize.outputs.archive_count }} archives (${{ steps.organize.outputs.deb_archive_count }} deb-based, ${{ steps.organize.outputs.rpm_archive_count }} rpm-based)

            ### Archive Structure

            Each `.zip` file contains packages for a specific **distribution + version + architecture** combination:
            - `debian-{version}-{arch}-packages.zip` - Debian packages
            - `ubuntu-{version}-{arch}-packages.zip` - Ubuntu packages
            - `rockylinux-{version}-{arch}-packages.zip` - Rocky Linux packages
            - `fedora-{version}-{arch}-packages.zip` - Fedora packages
            - And more...

            ### Available Distributions

            #### Debian-based (.deb packages)
            - **Debian**: 11, 12
            - **Ubuntu**: 20.04, 22.04, 24.04, 24.10
            - **Architectures**: amd64, arm64, armhf, i386

            #### RPM-based (.rpm packages)
            - **AlmaLinux**: 8, 9
            - **Amazon Linux**: 2, 2023
            - **CentOS**: 7, 9
            - **CentOS Stream**: 8, 9
            - **Fedora**: 39, 40, 41
            - **OpenSUSE**: 15.5, 15.6
            - **Oracle Linux**: 8, 9
            - **Rocky Linux**: 8, 9
            - **Architectures**: x86_64, aarch64

            ### Installation Instructions

            #### Step 1: Download
            Download the archive for your distribution, version, and architecture:
            ```bash
            # Example for Debian 12 on amd64
            wget https://github.com/${{ github.repository }}/releases/download/latest/debian-12-amd64-packages.zip

            # Example for Ubuntu 24.04 on amd64
            wget https://github.com/${{ github.repository }}/releases/download/latest/ubuntu-24.04-amd64-packages.zip
            ```

            #### Step 2: Verify Checksum
            ```bash
            # Download checksum file
            wget https://github.com/${{ github.repository }}/releases/download/latest/SHA256SUMS

            # Verify the archive
            sha256sum -c SHA256SUMS --ignore-missing
            ```

            #### Step 3: Update & install dependencies
            ```bash
            sudo apt update
            sudo apt upgrade -y
            sudo apt install -y unzip libsystemd0 libuv1 libjudydebian1 liblz4-1 zlib1g
            ```

            #### Step 4: Extract Archive
            ```bash
            # Extract the zip file
            unzip debian-12-amd64-packages.zip

            # Navigate to extracted directory
            cd debian-12-amd64-packages
            ```

            #### Step 5: Install Packages

            **For Debian/Ubuntu (.deb):**
            ```bash
            sudo dpkg -i netdata*.deb
            sudo apt-get install -f  # Fix any dependency issues
            ```

            **For RHEL/CentOS/Fedora/Rocky (.rpm):**
            ```bash
            sudo rpm -i netdata-*.rpm
            # or
            sudo dnf install netdata-*.rpm
            ```

            ### Notes
            - ‚ö†Ô∏è Packages are **unsigned** (fork build)
            - Each archive contains multiple package files (main package + plugins)
            - If some archives are missing, check the [workflow run](${{ steps.workflow-details.outputs.html_url }}) for build errors

          # Mark as latest release
          makeLatest: true

          # Use "latest" as the tag name
          tag: latest

          # Release name
          name: Latest Packages

          # GitHub token for authentication
          token: ${{ secrets.GITHUB_TOKEN }}

          # Don't fail if release already exists
          skipIfReleaseExists: false

      # Summary of what was uploaded
      - name: Release Summary
        if: steps.organize.outputs.has_archives == 'true'
        run: |
          echo "‚úÖ Release 'Latest Packages' has been updated successfully!"
          echo ""
          echo "üì¶ Uploaded package archives (${{ steps.organize.outputs.archive_count }} total):"
          echo "   - ${{ steps.organize.outputs.deb_archive_count }} Debian-based archives (.deb packages)"
          echo "   - ${{ steps.organize.outputs.rpm_archive_count }} RPM-based archives (.rpm packages)"
          echo ""
          echo "üîó View release at: ${{ github.server_url }}/${{ github.repository }}/releases/tag/latest"

      # Handle case where no archives were created
      - name: No Archives Warning
        if: steps.organize.outputs.has_archives != 'true'
        run: |
          echo "‚ö†Ô∏è No package archives were available to upload to release"
          echo "This might mean:"
          echo "  - All package builds failed in the packaging workflow"
          echo "  - No artifacts were generated"
          echo "  - Check the packaging workflow run for errors: ${{ steps.workflow-details.outputs.html_url }}"
          exit 0
